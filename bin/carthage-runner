#!/usr/bin/python3
import argparse, sys, gc, traceback, yaml
import asyncio, logging
from carthage.hadron_layout import database_key, external_network
from carthage.dependency_injection import AsyncInjector, InjectionKey
from carthage import base_injector, ssh
from carthage.network import Network
from carthage.container import container_image, Container
from carthage.hadron.database import RemotePostgres, HadronNetwork
from carthage.hadron import build_database, hadron_vm_image
from sqlalchemy.orm import Session
from carthage.machine import ssh_origin, Machine
import carthage.ssh

logger = logging.getLogger('carthage')

machines = []

async def load_layout(layout_file):
    layout = yaml.load(layout_file)
    for m in layout['machines']:
        machine_queue.put_nowait(m)
        ainjector = base_injector(AsyncInjector)
        brint = await ainjector(external_network)
    for n in layout.get('expose_networks', []):
        n = int(n)
        net = await ainjector.get_instance_async(InjectionKey(HadronNetwork, netid=n))
        vlanid = 1000+n
        iface = brint.expose_vlan(vlanid)
        net.add_member(iface)
        
        
async def queue_worker():
    global machines
    while True:
        name = await machine_queue.get()
        try:
            m_new = await ainjector.get_instance_async(InjectionKey(Machine, host = name))
            await m_new.start_machine()
            machines.append(m_new)
        except Exception:
            print('Error Creating {}'.format(name))
            traceback.print_exc()
        
        
async def run():

    asyncio.ensure_future(ainjector(hadron_vm_image))
    container = await ainjector.get_instance_async(database_key)
    await ainjector.get_instance_async(ssh_origin)
    await ainjector.get_instance_async(carthage.ssh.SshKey)
    async with container.container_running:
        await container.network_online()
        pg  = await ainjector(RemotePostgres)
        engine = pg.engine()
        session = Session(engine)
        await ainjector(build_database.provide_networks, session = session)
        session.close()
        await load_layout(args.layout)
        loop.create_task(queue_worker())
        loop.create_task(queue_worker())
        def callback():
            container.ssh("-A", _fg = True)
        try:
            await loop.run_in_executor(None, func = callback)
        except Exception:
            logger.exception('Command failed:')

            
        global machines
        futures = []
        for m in machines:
            if m.running:
                futures.append(loop.create_task(m.stop_machine()))
        await asyncio.wait(futures, timeout = 10)
        for m in machines:
            m.close()
    del machines
            

ainjector = base_injector(AsyncInjector)

loop = asyncio.get_event_loop()
machine_queue = asyncio.Queue()

parser = carthage.utils.carthage_main_argparser()
parser.add_argument("layout",
                         metavar = "layout_file",
                         type = argparse.FileType('rt'),
                         help = "Layout YAML configuration")

args = carthage.utils.carthage_main_setup(parser)




try:
    loop.run_until_complete(run())
finally:
    ainjector.close()
    base_injector.close()
    gc.collect()
