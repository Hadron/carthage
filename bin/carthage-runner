#!/usr/bin/python3
import argparse, os, sys, gc, traceback, yaml
import asyncio, logging
import carthage.vmware, carthage.console
from carthage.hadron_layout import database_key
from carthage.dependency_injection import AsyncInjector, InjectionKey, shutdown_injector
from carthage import base_injector, sh, ssh
from carthage.network import Network, BridgeNetwork, external_network_key
from carthage.container import container_image, Container
from carthage.hadron.database import RemotePostgres, HadronNetwork, only_permitted_vms
from carthage.hadron import build_database
from sqlalchemy.orm import Session
from carthage.machine import ssh_origin, Machine
import carthage.ssh

logger = logging.getLogger('carthage')

machines = []

async def load_layout(layout_file):
    layout = yaml.load(layout_file)
    for m in layout['machines']:
        machine_queue.put_nowait(m)
    ainjector = base_injector(AsyncInjector)
    external_network = await ainjector.get_instance_async(external_network_key)
    brint = await external_network.access_by(BridgeNetwork)
    for n in layout.get('expose_networks', []):
        n = int(n)
        net = await ainjector.get_instance_async(InjectionKey(HadronNetwork, netid=n))
        vlanid = 1000+n
        iface = brint.expose_vlan(vlanid)
        net = await net.access_by(BridgeNetwork)
        net.add_member(iface)

    permitted_vms = layout.get('permitted_vms', [])
    await ainjector(only_permitted_vms, permitted_vms)
    
        
async def queue_worker():
    global machines
    while True:
        name = await machine_queue.get()
        try:
            m_new = await ainjector.get_instance_async(InjectionKey(Machine, host = name))
            await m_new.start_machine()
            machines.append(m_new)
        except Exception:
            print('Error Creating {}'.format(name))
            traceback.print_exc()
        
        
async def run():

    container = await ainjector.get_instance_async(database_key)
    await ainjector.get_instance_async(ssh_origin)
    await ainjector.get_instance_async(carthage.ssh.SshKey)
    async with container.container_running:
        await container.network_online()
        pg  = await ainjector(RemotePostgres)
        engine = pg.engine()
        session = Session(engine)
        await ainjector(build_database.provide_networks, session = session)
        session.close()
        await load_layout(args.layout)
        if args.make_update:
            await container.make_update()
        queue_workers.append(loop.create_task(queue_worker()))
        queue_workers.append(loop.create_task(queue_worker()))
        try:
            console.locals['db'] = container
            console.locals['ainjector'] = ainjector
            console.locals['pg'] = pg
            console.locals['in_tmux'] = 'TMUX' in os.environ
            console.exec_resource('carthage', 'resources/runner_console.py')
            await loop.run_in_executor(None, console.interact)
        except Exception:
            logger.exception('console failed:')

        
            
        global machines
        futures = []
        for m in machines:
            if m.running:
                futures.append(loop.create_task(m.stop_machine()))
        await asyncio.wait(futures, timeout = 10)
        for m in machines:
            m.close()
    del machines
            

    
ainjector = base_injector(AsyncInjector)

loop = asyncio.get_event_loop()
machine_queue = asyncio.Queue()

parser = carthage.utils.carthage_main_argparser()
parser.add_argument("layout",
                         metavar = "layout_file",
                         type = argparse.FileType('rt'),
                         help = "Layout YAML configuration")
parser.add_argument('--vmware', action='store_true',
                    help = 'Use VmWare for virtualization')
parser.add_argument('--make-update', '-m',
                    help = "Run make update in /hadron-operations on test-database",
                    action = 'store_true')
parser.add_argument('--no-tmux', action = 'store_false',
                    dest = 'tmux', default = True,
                    help = "Do not start a tmux for the console")


console = carthage.console.CarthageConsole()
console.add_arguments(parser)

args = carthage.utils.carthage_main_setup(parser)


# First see if we need to rexec
if 'TMUX' not in os.environ and  args.tmux:
    os.execvp("tmux", ["tmux", "new-session", "-A", "-scarthage",
                       ]+sys.argv)


console.process_arguments(args)
if args.vmware:
    from carthage import vmware
    import carthage.hadron.build_database, carthage.hadron.vmware
    base_injector.add_provider(InjectionKey(vmware.VmTemplate), carthage.hadron.vmware.aces_vm_template)
    carthage.hadron.build_database.vm_class = vmware.Vm




try:
    queue_workers = []
    loop.run_until_complete(run())
    for q in queue_workers:
        q.cancel()
finally:
    loop.run_until_complete(shutdown_injector(base_injector))
    gc.collect()
